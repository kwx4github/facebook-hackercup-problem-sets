#include <algorithm>
#include <iomanip>
#include <istream>
#include <map>
#include <ostream>
#include <set>
#include <sstream>
#include <utility>
#include <vector>


using namespace std;

// Solution template generated by caide

struct Pos {
	int turn, x, y;
};

class Solution {
public:
    void solve(std::istream& in, std::ostream& out) {
		int T;
		in >> T;
		for (int test = 1; test <= T; ++test) {
			int M, N;
			in >> M >> N;
			vector<string> map(M);
			for (int i = 0; i < M; ++i)
				in >> map[i];
			vector<vector<vector<bool> > > good(4);
			int sx = -1, sy = 0;
			for (int turn = 0; turn < 4; ++turn) {
				good[turn].resize(M);
				for (int i = 0; i < M; ++i) {
					good[turn][i].resize(N);
					for (int j = 0; j < N; ++j) {
						good[turn][i][j] = (map[i][j] == '.' || map[i][j] == 'S' || map[i][j] == 'G');
						if (map[i][j] == 'S') {
							sx = i;
							sy = j;
						}
					}
				}

				for (int turretX = 0; turretX < M; ++turretX) for (int turretY = 0; turretY < N; ++turretY) {
					int dx = 0, dy = 0;
					switch (map[turretX][turretY]) {
					case '<':
						dy = -1; break;
					case '>':
						dy = 1; break;
					case '^':
						dx = -1; break;
					case 'v':
						dx = 1; break;
					}
					if (!dx && !dy)
						continue;

					for (int x = turretX + dx, y = turretY + dy;
							x >= 0 && x < M && y >= 0 && y < N && (map[x][y] == '.' || map[x][y] == 'S' || map[x][y] == 'G');
							x += dx, y += dy)
					{
						good[turn][x][y] = false;
					}

				}

				for (int i = 0; i < M; ++i) for (int j = 0; j < N; ++j) switch (map[i][j])
				{
				case '<': map[i][j] = '^'; break;
				case '^': map[i][j] = '>'; break;
				case '>': map[i][j] = 'v'; break;
				case 'v': map[i][j] = '<'; break;
				}
			}

			vector<Pos> front;
			front.push_back({ 0, sx, sy });
			int turn = 0;
			bool found = false;
			while (!found && !front.empty()) {
				vector<Pos> next;
				for (const Pos& pos : front) {
					if (map[pos.x][pos.y] == 'G') {
						found = true;
						break;
					}

					for (int dx = -1; dx <= 1; ++dx) for (int dy = -1; dy <= 1; ++dy) if ((dx == 0) ^ (dy == 0)) {
						Pos pos1 = { (turn + 1) % 4, pos.x + dx, pos.y + dy };
						if (pos1.x < 0 || pos1.x >= M || pos1.y < 0 || pos1.y >= N) {
							continue;
						}
						if (!good[pos1.turn][pos1.x][pos1.y])
							continue;
						good[pos1.turn][pos1.x][pos1.y] = false;
						next.push_back(pos1);
					}
				}

				front.swap(next);
				++turn;
			}

			out << "Case #" << test << ": ";
			if (found)
				out << (turn - 1);
			else
				out << "impossible";

			out << endl;
		}
    }
};

void solve(std::istream& in, std::ostream& out)
{
    out << std::setprecision(12);
    Solution solution;
    solution.solve(in, out);
}


#include <iostream>


int main() {
    std::ios_base::sync_with_stdio(0);
    std::cin.tie(0);
    solve(std::cin, std::cout);
    return 0;
}






























// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <windows.h>
#include <cstring>
using namespace std;
#define LL long long

#define maxn 110
#define maxe 300010
#define INF 2100000000
int n, m;
char mm[maxn][maxn];
char g[maxn][maxn][5];
int fob[maxn][maxn][5];
char fx[] = ">v<^";
int get(char c)
{
	if (c == '>') return 0;
	if (c == 'v') return 1;
	if (c == '<') return 2;
	if (c == '^') return 3;
	return -1;
}
int get1(char c)
{
	if (c == '.' || c == 'S' || c == 'G') return 1;
	return 0;
}
void init(int d)
{
	int i, j, k;
	for (i = 0; i<n; i++)
	{
		for (j = 0; j<m; j++)if (get(mm[i][j]) != -1)
		{
			char c = fx[(get(mm[i][j]) + d) % 4];
			if (c == '<')
			for (k = j - 1; k >= 0 && get1(mm[i][k]); k--)
				fob[i][k][d] = 1;
			else if (c == 'v')
			for (k = i + 1; k<n&&get1(mm[k][j]); k++)
				fob[k][j][d] = 1;
			else if (c == '>')
			for (k = j + 1; k<m&&get1(mm[i][k]); k++)
				fob[i][k][d] = 1;
			else
			for (k = i - 1; k >= 0 && get1(mm[k][j]); k++)
				fob[k][j][d] = 1;
		}
	}
}
struct node{
	int x, y;
	int d;
	node(){};
	node(int _x, int _y, int _d)
	{
		x = _x, y = _y, d = _d;
	}
	
}s, e;
#define INF 1<<30
queue<node>q;
int d[maxn][maxn][4];
int dx[] = { 0, 1, -1, 0 };
int dy[] = { 1, 0, 0, -1 };
void bfs()
{
	int i, j, k;
	memset(d, -1, sizeof(d));
	d[s.x][s.y][0] = 0;
	q.push(node(s.x, s.y, 0));
	while (!q.empty())
	{
		node ss = q.front(); q.pop();
		for (i = 0; i<4; i++)
		{
			int tx = dx[i] + ss.x;
			int ty = dy[i] + ss.y;
			if (tx < 0 || tx >= n || ty < 0 || ty >= m) continue;
			if (!get1(mm[tx][ty])) continue;
			int td = ss.d + 1;
			if (d[tx][ty][td % 4] == -1&&!fob[tx][ty][td%4]){
				d[tx][ty][td % 4] = td;
				q.push(node(tx, ty, td));
			}
		}
	}
}
int main()
{
	freopen("laser_maze.txt", "r", stdin);
	freopen("laser_maze.out", "w", stdout);
	int ncase, i, j, k, tt = 0;
	scanf("%d", &ncase);
	while (ncase--)
	{
		scanf("%d %d", &n, &m);
		for (i = 0; i<n; i++)scanf("%s", mm[i]);
		memset(fob, 0, sizeof(fob));
		for (i = 0; i<4; i++)
			init(i);
		for (i = 0; i<n; i++)
		for (j = 0; j<m; j++)
		if (mm[i][j] == 'S')
			s = node(i, j, 0);
		else if (mm[i][j] == 'G')
			e = node(i, j, 0);
		bfs();
		int ans = INF;
		for (i = 0; i<4; i++)if (d[e.x][e.y][i] != -1)
			ans = min(ans, d[e.x][e.y][i]);
		if (ans == INF) printf("Case #%d: impossible\n", ++tt);
		else printf("Case #%d: %d\n", ++tt, ans);
	}
	return 0;
}
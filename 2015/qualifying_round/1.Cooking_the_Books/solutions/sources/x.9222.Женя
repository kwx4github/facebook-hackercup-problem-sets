#include <fstream>
#include <vector>


void printVecToFile(std::ofstream& file, const std::vector <int>& vec)
{
	for (auto it = vec.begin(); it != vec.end(); it++)
		file << *it;

	return;
}


// „исло в vec будет записано в пр€мом пор€дке. 
// i = 123; vec [0] = 1, vec [1] = 2; vec [2] = 3
void intToVec(int i, std::vector <int>& vec)
{
	if (i == 0)
	{
		vec.push_back(0);
		return;
	}
		

	while (i != 0)
	{
		vec.push_back(i % 10);
		i /= 10;
	}

	std::reverse(vec.begin(), vec.end());
}

void searchMin(std::vector <int>& vec, int nach)
{
	if (nach >= vec.size())
		return;

	
	int minn = 10, nu = 0, j, jnu;
	for (int i = nach; i < vec.size(); ++i)
	{
		if ((vec[i] <= minn) && (vec[i] != 0)) // ищу минимум среди не равных нулю // vec [i] почти всегда не равен 0. »мелось ввиду &&? да, € их путаю
		{
			minn = vec[i];
			j = i; // потому что если <= то он запомнит самый правый из минимальных
		}
		if (vec[i] == 0) // считаю нули и запоминаю на каком месте последний нуль
		{
			++nu;
			jnu = i; 
		}
	}

	if (nu != 0) // если нули есть, 
	{
		if (j == nach) // если минимальный на 1м месте
			std::swap(vec[nach + 1], vec[jnu]); // ставим нуль на 2е место что значит "второе" место? 
		else 
			std::swap(vec[nach], vec[j]); // иначе ставим минимальный элемент (не нуль) на первое место по идее он должен зайти сюда, а тут норм всЄ
	}
	else
	{
		if ((j != nach)&&(minn != vec[nach])) // иначе и если минимальный элемент не на первом месте
		{
			std::swap(vec[nach], vec[j]); // мен€ем мин и первый 
		}
		else
		{
			searchMin(vec, ++nach); // ищем минимальный среди всех кроме первого (то есть со второго по послед. в массиве)
		}
	}
}//всЄ

void searchMax(std::vector <int>& vec, int nach)
{
	if (nach >= vec.size())
		return;


	int maxx = 0, j = nach;
	for (int i = nach; i < vec.size(); ++i)
	{
		if (vec[i] >= maxx)
		{
			maxx = vec[i];
			j = i;
		}
	}
	if (vec[nach] != maxx)
		std::swap(vec[nach], vec[j]);
	else
		searchMax(vec, ++nach);
}

int main()
{
	std::ofstream outFile;
	outFile.open("out.txt");

	std::ifstream inFile;
	inFile.open("in.txt");
	
	int N;
	inFile >> N;


	for (int i = 0; i < N; ++i) // ќсновной цикл программы
	{
		std::vector <int> minNum, maxNum;
		minNum.reserve(11); maxNum.reserve(11);

		int num;
		inFile >> num;
		intToVec(num, minNum);
		maxNum = minNum;

		if (num / 10 == 0)
		{
			outFile << "Case #" << i + 1 << ": ";
			printVecToFile(outFile, minNum);
			outFile << " ";
			printVecToFile(outFile, maxNum);
			outFile << std::endl;
		}
		else
		{
			// Ќайти минимальное
			searchMin(minNum, 0);

			// Ќайти максимальное
			searchMax(maxNum, 0);

			// ¬ывод 
			outFile << "Case #" << i + 1 << ": ";
			printVecToFile(outFile, minNum);
			outFile << " ";
			printVecToFile(outFile, maxNum);
			outFile << std::endl;
		}
	}

	inFile.close();
	outFile.close();
	return 0;
}